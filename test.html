<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>æµ‹è¯• EChartsï¼ˆæ—  SSEï¼‰</title>
    <style>
      body {
        font-family: Arial, "Microsoft Yahei", sans-serif;
        padding: 12px;
      }
      #clock {
        font-size: 18px;
        margin-bottom: 12px;
      }
      #chart {
        width: 100%;
        height: 420px;
        max-width: 900px;
        border: 1px solid #ddd;
      }
      #status {
        color: #666;
        margin-top: 8px;
      }
    </style>
  </head>
  <body>
    <h2>å®æ—¶å›¾è¡¨ â€” EChartsï¼ˆæ¨¡æ‹Ÿæ•°æ®ç¤ºä¾‹ï¼Œä¸ä½¿ç”¨ SSEï¼‰</h2>
    <div id="ad">ad</div>
    <div id="clock">ç­‰å¾…æ•°æ®â€¦</div>
    <div id="chart"></div>
    <div id="status">è¿è¡Œä¸­ï¼ˆæ¨¡æ‹Ÿå®æ—¶æ•°æ®ï¼‰</div>

    <!-- ECharts CDN -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>

    <!-- <script>
      // åˆå§‹åŒ–å›¾è¡¨
      const chartDom = document.getElementById("chart");
      const myChart = echarts.init(chartDom);
      const clockDiv = document.getElementById("clock");
      const statusDiv = document.getElementById("status");

      const maxPoints = 30;
      const xData = [];
      const yData = [];

      const option = {
        title: { text: "å®æ—¶æ•°æ®ï¼ˆæ¨¡æ‹Ÿï¼‰", left: "center" },
        tooltip: { trigger: "axis" },
        xAxis: {
          type: "category",
          boundaryGap: false,
          data: xData,
        },
        yAxis: { type: "value" },
        series: [
          {
            name: "å€¼",
            type: "line",
            smooth: true,
            data: yData,
            showSymbol: false,
            areaStyle: { opacity: 0.2 },
            lineStyle: { width: 2 },
          },
        ],
        grid: { left: "6%", right: "4%", bottom: "8%" },
      };

      myChart.setOption(option);
      // window.addEventListener("resize", () => myChart.resize());
      new ResizeObserver((entries) => myChart.resize()).observe(
        document.querySelector("#chart")
      );

      // ä½¿ç”¨å®šæ—¶å™¨æ¨¡æ‹Ÿå®æ—¶æ•°æ®ï¼ˆæ¯ç§’ï¼‰
      setInterval(() => {
        const now = new Date();
        const label = now.toLocaleTimeString();
        // æ¨¡æ‹Ÿæ•°æ®ï¼Œå¯æ›¿æ¢ä¸ºçœŸå®å€¼
        const value = Math.round(
          50 + 30 * Math.sin(now.getTime() / 1000) + Math.random() * 10
        );

        // æ¨å…¥æ•°æ®å¹¶ä¿æŒé•¿åº¦
        xData.push(label);
        yData.push(value);
        if (xData.length > maxPoints) {
          xData.shift();
          yData.shift();
        }

        clockDiv.textContent = label + " â€” å½“å‰å€¼: " + value;
        myChart.setOption({
          xAxis: { data: xData },
          series: [{ data: yData }],
        });
      }, 1000);

      // å¦‚æœä½ æœªæ¥æ¢å¤ SSEï¼Œä¸‹é¢æ˜¯æŠŠ SSE çš„æ•°æ®å’Œä¸Šé¢çš„æµç¨‹ç»“åˆçš„æ³¨é‡Šç¤ºä¾‹ï¼š
      /*
      // SSE ç¤ºä¾‹ï¼ˆæ³¨é‡Šæ‰ï¼‰
      const evt = new EventSource('/sse');
      evt.onopen = () => { statusDiv.textContent = 'SSE å·²è¿æ¥'; };
      evt.onmessage = (e) => {
        // å‡å®šåç«¯å‘é€ JSON: { time: '08:00:00', value: 42 }
        try {
          const payload = JSON.parse(e.data);
          const label = payload.time || new Date().toLocaleTimeString();
          const value = payload.value !== undefined ? payload.value : Math.random() * 100;
          // ...å°† labelã€value å†™å…¥å›¾è¡¨ï¼ˆå‚è€ƒä¸Šé¢ setInterval éƒ¨åˆ†ï¼‰
        } catch(err) {
          console.warn('è§£æ SSE æ•°æ®å¤±è´¥', err);
        }
      };
      evt.onerror = (err) => {
        statusDiv.textContent = 'SSE è¿æ¥é”™è¯¯';
        console.error(err);
      };
      */
    </script> -->

    <script>
      // sw.registration.backgroundFetch.fetch("pkg", ["/1.zip", "/2.zip"]);

      // const writer = (await fetch(url, {method: 'POST', body: stream})).body.getWriter();

      //       const reader = response.body.getReader();
      // while (true) {
      //   const {done, value} = await reader.read();
      //   if (done) break;
      //   await writeChunk(value);
      // }
      // const ctrl = new AbortController();
      // const url = "https://jsonplaceholder.typicode.com/posts";
      // fetch(url, { signal: ctrl.signal });
      // setTimeout(() => {
      //   ctrl.abort("æ“ä½œè¶…æ—¶"); // æä¾›å–æ¶ˆçš„åŸå› 
      // }, 1000);

      // const refreshData = () => {
      //   console.log("Refreshing data in background...");
      //   // æ¨¡æ‹Ÿæ•°æ®åˆ·æ–°çš„æ“ä½œ
      // };
      // scheduler.postTask(refreshData, { priority: "background" });

      // const sendLogs = () => {
      //   console.log("Sending logs to server...");
      //   // æ¨¡æ‹Ÿå‘é€æ—¥å¿—çš„æ“ä½œ
      // };
      // requestIdleCallback(() => sendLogs(), { timeout: 2000 });

      // document.addEventListener("visibilitychange", () => {
      //   document.hidden ? video.pause() : video.play();
      // });
      // const ad = document.getElementById("ad");
      // const token = "abcdefg1234567";
      // new BroadcastChannel("login").postMessage({ token });
      // // è‡ªå®šä¹‰ analytics å¯¹è±¡
      // const analytics = {
      //   send: function (name, value) {
      //     // è¿™é‡Œå¯ä»¥æ›¿æ¢ä¸ºå®é™…çš„æ•°æ®å‘é€é€»è¾‘
      //     console.log("æ€§èƒ½æŒ‡æ ‡:", name, value);
      //   },
      // };

      // // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒ PerformanceObserver
      // if ("PerformanceObserver" in window) {
      //   // åˆ›å»ºæ€§èƒ½è§‚å¯Ÿå™¨
      //   new PerformanceObserver((list) => {
      //     for (const entry of list.getEntries()) {
      //       analytics.send(entry.name, entry.startTime);
      //     }
      //   }).observe({ type: "paint" });
      // } else {
      //   console.log("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ PerformanceObserver");
      // }

      // new PerformanceObserver((list) => {
      //   for (const entry of list.getEntries())
      //     analytics.send(entry.name, entry.startTime);
      // }).observe({ type: "paint" });
      //       const p = new URLSearchParams({ q: "å‰ç«¯", year: 2025 });
      // console.log(p.toString()); // q=%E5%89%8D%E7%AB%AF&year=2025
      // ad.onclick = async () => {
      // const decoder = new VideoDecoder({
      //   output: (frame) => canvas.draw(frame),
      //   error: (e) => console.error(e),
      // });
      // decoder.configure({ codec: "hvc1.1.6.L120.90" });
      // };
      // const { sRGBHex } = await new EyeDropper().open();
      // console.log("ğŸš€ ~ sRGBHex:", sRGBHex);
      // try {
      //   await navigator.clipboard.writeText("Hello, 2025!");
      // } catch (error) {
      //   console.error("å¤åˆ¶å¤±è´¥:", error);
      // }
      // const lock = await navigator.wakeLock.request("screen");
      // console.log("ğŸš€ ~ lock:", lock);
      // navigator.share({
      //   title: "ç™½çš®ä¹¦",
      //   text: "2025 å‰ç«¯è¶‹åŠ¿",
      //   url: location.href,
      // });
      // console.log(1, navigator);
      // console.log(2, window);
      // console.log(11, navigator.share);
    </script>
  </body>
</html>
